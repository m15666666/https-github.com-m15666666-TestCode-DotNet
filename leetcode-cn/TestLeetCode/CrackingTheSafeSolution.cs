using System;
using System.Collections.Generic;
using System.Text;

/*
有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。

你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。

举个例子，假设密码是 "345"，你可以输入 "012345" 来打开它，只是你输入了 6 个字符.

请返回一个能打开保险箱的最短字符串。

示例1:

输入: n = 1, k = 2
输出: "01"
说明: "10"也可以打开保险箱。
 
示例2:

输入: n = 2, k = 2
输出: "00110"
说明: "01100", "10011", "11001" 也能打开保险箱。
 
提示：

n 的范围是 [1, 4]。
k 的范围是 [1, 10]。
k^n 最大可能为 4096。

*/

/// <summary>
/// https://leetcode-cn.com/problems/cracking-the-safe/
/// 753. 破解保险箱
///
/// </summary>
internal class CrackingTheSafeSolution
{
    public static void Test()
    {
        //int[] nums = new int[] {3, 2, 4};
        //int k = 6;
        //var ret = LevelOrder((int[]) nums.Clone(), k);

        //Console.WriteLine(string.Join(",", ret.Select(v => v.ToString())));
    }

    public string CrackSafe(int n, int k)
    {
        var ret = new StringBuilder();
        if (n == 1)
        {
            for (int i = 0; i < k; i++) ret.Append(i);
            return ret.ToString();
        }

        HashSet<int> seen = new HashSet<int>();

        int highest = (int)Math.Pow(10, n - 1);
        Dfs(0);
        for (int i = 1; i < n; i++) ret.Append('0');
        return ret.ToString();

        void Dfs(int node)
        {
            for (int i = 0; i < k; ++i)
            {
                int edge = node * 10 + i;
                if (seen.Contains(edge)) continue;

                seen.Add(edge);
                var nextNode = edge % highest;
                Dfs(nextNode);
                ret.Append(i);
            }
        }
    }
}

/*
破解保险箱
力扣官方题解
发布于 2020-08-29
1.3k
前言
本题和 332. 重新安排行程 类似，是力扣平台上为数不多的求解欧拉回路 / 欧拉通路的题目。读者可以配合着进行练习。

方法一：\text{Hierholzer}Hierholzer 算法
\text{Hierholzer}Hierholzer 算法可以在一个欧拉图中找出欧拉回路。

具体地，我们将所有的 n-1n−1 位数作为节点，共有 k^{n-1}k 
n−1
  个节点，每个节点有 kk 条入边和出边。如果当前节点对应的数为 a_1 a_2 \cdots a_{n-1}a 
1
​	
 a 
2
​	
 ⋯a 
n−1
​	
 ，那么它的第 xx 条出边就连向数 a_2 \cdots a_{n-1} xa 
2
​	
 ⋯a 
n−1
​	
 x 对应的节点。这样我们从一个节点顺着第 xx 条边走到另一个节点，就相当于输入了数字 xx。

在某个节点对应的数的末尾放上它的某条出边的编号，就形成了一个 nn 位数，并且每个节点都能用这样的方式形成 kk 个 nn 位数。

例如 k=4k=4，n=3n=3 时，节点分别为 00, 01, 02, \cdots, 32, 3300,01,02,⋯,32,33，每个节点的出边的编号分别为 0, 1, 2, 30,1,2,3，那么 0000 和它的出边形成了 000, 001, 002, 003000,001,002,003 这 44 个 33 位数，3232 和它的出边形成了 320, 321, 322, 323320,321,322,323 这 44 个 33 位数。

这样共计有 k^{n-1} \times k = k^nk 
n−1
 ×k=k 
n
  个 nn 位数，恰好就是所有可能的密码。

由于这个图的每个节点都有 kk 条入边和出边，因此它一定存在一个欧拉回路，即可以从任意一个节点开始，一次性不重复地走完所有的边且回到该节点。因此，我们可以用 \text{Hierholzer}Hierholzer 算法找出这条欧拉回路：

设起始节点对应的数为 uu，欧拉回路中每条边的编号为 x_1, x_2, x_3, \cdotsx 
1
​	
 ,x 
2
​	
 ,x 
3
​	
 ,⋯，那么最终的字符串即为

u ~ x_1 ~ x_2 ~ x_3 \cdots
u x 
1
​	
  x 
2
​	
  x 
3
​	
 ⋯

\text{Hierholzer}Hierholzer 算法如下：

我们从节点 uu 开始，任意地经过还未经过的边，直到我们「无路可走」。此时我们一定回到了节点 uu，这是因为所有节点的入度和出度都相等。

回到节点 uu 之后，我们得到了一条从 uu 开始到 uu 结束的回路，这条回路上仍然有些节点有未经过的出边。我么从某个这样的节点 vv 开始，继续得到一条从 vv 开始到 vv 结束的回路，再嵌入之前的回路中，即

u \to \cdots \to v \to \cdots \to u
u→⋯→v→⋯→u

变为

u \to \cdots \to v \to \cdots \to v \to \cdots \to u
u→⋯→v→⋯→v→⋯→u

以此类推，直到没有节点有未经过的出边，此时我们就找到了一条欧拉回路。

实际的代码编写具有一定的技巧性。


class Solution {
    Set<Integer> seen = new HashSet<Integer>();
    StringBuffer ans = new StringBuffer();
    int highest;
    int k;

    public String crackSafe(int n, int k) {
        highest = (int) Math.pow(10, n - 1);
        this.k = k;
        dfs(0);
        for (int i = 1; i < n; i++) {
            ans.append('0');
        }
        return ans.toString();
    }

    public void dfs(int node) {
        for (int x = 0; x < k; ++x) {
            int nei = node * 10 + x;
            if (!seen.contains(nei)) {
                seen.add(nei);
                dfs(nei % highest);
                ans.append(x);
            }
        }
    }
}
复杂度分析

时间复杂度：O(n \times k^n)O(n×k 
n
 )。

空间复杂度：O(n \times k^n)O(n×k 
n
 )。
 
一步一步推导出 0ms 解法（贪心构造）
newhar
发布于 2020-06-04
1.3k
题意描述
求出一个最短的字符串，使其包含从 0 \sim k^n0∼k 
n
 （kk 进制）中的所有数字。

题意转化
首先对题意进行转化和抽象，具体方式类似官方题解，即将所有的 n-1n−1 位数作为节点。每个节点有 kk 条边，节点上添加数字 0 \sim k-10∼k−1 视为一条边。

举例说明，如 n=3,k=2n=3,k=2（三位二进制数），其节点（二位二进制数）为 “00”，“01”，“10”，“11”“00”，“01”，“10”，“11”，每个节点有 22 条边，节点上添加数字 0 \sim 10∼1 可转化到自身或另一个节点，如下图所示。

image.png

如果我们从任一节点出发，能够找出一条路径，经过图中的所有边且只经过一次，然后把边上的数字写入字符串（还需加入起始节点的数字），那么这个字符串显然符合要求，而且找不出比它更短的字符串了。

直观解法
直觉上，有一种思路，就是从任一节点开始，从 0 \sim k-10∼k−1 遍历，只要有可用的路就走，直到无法继续为止。
仍以 n=3,k=2n=3,k=2 为例：



我们走到了起始点 “00”“00”，发现没有路可以走了，但是，仍有一些边没有遍历到。

image.png

这时该怎么办？

一种方法是官方题解中给出的，我们另选一个节点，从该节点出发，再找一条路径（01→11→11→10→01）：

image.png

然后把它和一开始的路径（00→00→ [01] →10→00）结合起来（00→00→ [01→11→11→10→01] →10→00）即可。这是官方的 dfs 思路。

贪心构造算法
但是我们还有一种更简单的贪心思路。
注意到，当我们无路可走时，一定是在起始点，并且起始点的所有边都已经过。 这是因为所有节点的入度和出度均为 kk。如果我们不在起始点，那 “只要有进去的路，就一定还有至少一条出去的路”。

再看之前出现的无路可走的情况（下图），我们发现，起始点回的太早了。从贪心的角度来想，如果可以 尽可能晚返回起始点，就能遍历更多的边。

image.png

如果实现这个算法呢？很简单，稍微改动之前的算法即可。我们选择 “00”“00” 作为起始点。但是每次要选择添加的数字时，从大数字开始（即从 k-1k−1 遍历到 00）。这样可以尽可能晚地回到起始点。

首先拿上面 n=3, k=2n=3,k=2 的例子验证一下：



是不是感觉很神奇。

代码也很简单

class Solution {
public:
    string crackSafe(int n, int k) {
        int kn = pow(k, n), kn_1 = pow(k, n-1), num[kn_1];
        fill(num, num + kn_1, k-1);
        string s(kn + (n-1), '0');
        for(int i = n-1, node = 0; i < s.size(); ++i) {
            s[i] = num[node]-- + '0';
            node = node*k - (s[i-(n-1)]-'0')*kn_1 + num[node] + 1;
        }
        return s;
    }
};
时间复杂度： O(k^n)O(k 
n
 )。
空间复杂度： O(k^n)O(k 
n
 )。如果不考虑输出字符串，为 O(k^{n-1})O(k 
n−1
 )。

正确性证明（进阶）
下面从原理上证明一下。
我们简化一下上面的图，仅画出添加的数字为 ‘0’‘0’ 的边：

image.png

有没有感觉像一棵树。实际上，忽略箭头的方向，再忽略节点 “00”“00” 上的自环，这就是一棵树。
好了，下面我就把它当成一棵“伪树”了，根节点为 “00”“00”。

我们从根节点 “00”“00” 出发，首先选择数字 ‘1’‘1’ 的边（简称 出边 11，图中省略）进行遍历。
不管之后如何遍历，我们一定会再次返回节点 “00”“00”。那我们会从哪个节点返回呢？一定其“子”节点 “10”“10”，添加数字 ‘0’‘0’ 后返回。
那么，节点 “10”“10” 既然遍历了 出边 00，那么其 出边 11（图中省略）自然也已经被遍历了，因为我们从大到小遍历添加的数字。这样，节点 “10”“10” 被遍历了 22 次。
节点 “10”“10” 可以由其 “子”节点 “01”“01”、“11”“11” 添加数字 ‘0’‘0’ 到达。因为节点 “10”“10” 被遍历了 22 次，所以节点 “01”“01”、“11”“11” 的 出边 00 遍历过。那么同理，其 出边 11 也一定被遍历过，因此节点 “01”“01”、“11”“11” 也都被遍历过 22 次。
综上所述，当我们返回节点 “00”“00” 时，其余节点都遍历了 22 次。这表明此时，除了节点 “00”“00” 的自环之外，其余节点的所有边都已经被遍历。因此我们只需遍历节点 “00”“00” 的自环即可遍历完所有的边。这样，当我们最后一次返回节点 0000 （即通过自环返回时），所有节点的所有边都已被遍历。
大家也可以对照上面的动图来理解一下。
对于其他示例，我们也可以只画出数字为 ‘0’‘0’ 的边，构造出类似的“树”装结构。
如 n=3,k=3n=3,k=3 时为：

image.png

通过类似的证明可得，采用该算法，当我们最后一次返回节点 0000 时，原有向图中的所有边都已被遍历。

针对 n=3,k=3n=3,k=3 的情况，程序运行的过程如下图所示，可以根据程序运行的过程来理解算法的正确性。



针对一般情况的证明：

对于任意 n,kn,k，图中共有 k^{n-1}k 
n−1
  个节点，每个节点有 kk 条边连入，kk 条边连出，共 k^nk 
n
  条边。
仅考虑对应数字为 ‘0’‘0’ 的边，则每个节点有 11 条边，共有 k^{n-1}k 
n−1
  条边。若忽略节点 00 的自环，则共有 k^{n-1} - 1k 
n−1
 −1 条边。
若不考虑边的方向，则这 k^{n-1}k 
n−1
  个节点一定同属一个连通域，因为任何节点都可以通过不断添加 ‘0’‘0’ 到达节点 00，从而与节点 00 联通。因此这 k^{n-1}k 
n−1
  个节点、 k^{n-1} - 1k 
n−1
 −1 条边只能形成一个树状结构。令节点 00 为根节点。
从根节点 00 开始遍历。当我们最后一次进入根节点时，根节点的所有边（指原有向图中的边）已被遍历。因此根节点的所有（直连）子节点（1...01...0、2...02...0 ~ k-1...0k−1...0，共 k-1k−1 个）的 出边 00 也已被遍历。由于我们从大到小遍历边，因此子节点的 所有出边 被遍历过。又因为节点的入边和出边数量相等，所以其 所有入边 也被遍历过。
类似地思路可以地推得，若一 非叶节点 的所有边都被遍历，其所有的（直连）子节点 的 所有边 也都被遍历了。
通过递归地分析可知，当我们最后一次进入根节点时，原有向图中的所有边已被遍历。

*/